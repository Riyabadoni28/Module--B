//Program of Breath First Search Algorithm
#include<iostream>
#include <list>

using namespace std;

class GraphOfBreathFirstSearch
{
	int Vertices; 
	// Pointer to an array containing adjacency of graph nodes
	// lists
	list<int> *adjacent;
public:
	GraphOfBreathFirstSearch(int Vertices); 

	void addEdgeToGraph(int vertices, int width);
	void BreathFirstSearch(int source);
};

GraphOfBreathFirstSearch::GraphOfBreathFirstSearch(int Vertices)
{
	this->Vertices = Vertices;
	adjacent = new list<int>[Vertices];
}

void GraphOfBreathFirstSearch::addEdgeToGraph(int vertices, int width)
{
	adjacent[vertices].push_back(width); // Add width to verticesâ€™s list.
}

void GraphOfBreathFirstSearch::BreathFirstSearch(int source)
{
	bool *visited = new bool[Vertices];
	for(int j = 0; j< Vertices; j++)
		visited[j] = false;

	// Create a queue for BreathFirstSearch
	list<int> queue;

	visited[source] = true;
	queue.push_back(source);

	list<int>::iterator j;

	while(!queue.empty())
	{
		source = queue.front();
		cout << source << " ";
		queue.pop_front();

		for (j = adjacent[source].begin(); j != adjacent[source].end(); ++j)
		{
			if (!visited[*j])
			{
				visited[*j] = true;
				queue.push_back(*j);
			}
		}
	}
}

//main methode of program
int main()
{

	GraphOfBreathFirstSearch graph(4);
	graph.addEdgeToGraph(1, 1);
	graph.addEdgeToGraph(1, 2);
	graph.addEdgeToGraph(2, 2);
	graph.addEdgeToGraph(2, 0);
	graph.addEdgeToGraph(2, 3);
	graph.addEdgeToGraph(3, 3);

	cout << "Following is Breadth First Traversal "
		<< "(starting from vertex 2) \n";
	graph.BreathFirstSearch(2);

	return 0;
}
# Breath First Search Algorithm
class GraphOfBreathFirstSearch:

	# Constructor of function
	def __init__(self):

		self.graphOfBreathFirstSearch = defaultdict(list)

	
	def addEdgeInGraph(self,u,v):
		self.graph[u].append(v)

	# Function to print a BFS of graph
	def BFS(self, s):

		# Mark all the vertices as not visited
		visited = [False] * (max(self.graph) + 1)

		# Create a queue for BFS
		queue = []

		# Mark the source node as
		# visited and enqueue it
		queue.append(s)
		visited[s] = True

		while queue:

			# Dequeue a vertex from
			# queue and print it
			s = queue.pop(0)
			print (s, end = " ")

			# Get all adjacent vertices of the
			# dequeued vertex s. If a adjacent
			# has not been visited, then mark it
			# visited and enqueue it
			for i in self.graph[s]:
				if visited[i] == False:
					queue.append(i)
					visited[i] = True

# Driver code

# Create a graph given in
# the above diagram
g = Graph()
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(1, 2)
g.addEdge(2, 0)
g.addEdge(2, 3)
g.addEdge(3, 3)

print ("Following is Breadth First Traversal"
				" (starting from vertex 2)")
g.BFS(2)

# This code is contributed by Neelam Yadav
